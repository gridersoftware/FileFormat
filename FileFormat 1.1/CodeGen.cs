using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;
using FileFormat.Languages;

namespace FileFormat
{
    class CodeGen<T>
        where T : Language 
    {
        #region ParseState

        CompoundType<T> root;
        CompoundType<T> current = null;
        CompoundType<T> newest;

        T file;
        T ns;

        Dictionary<string, Constant> constants;

        bool ffinit = false;    // determines if the #FORMATNAME directive has been used
        bool nsinit = false;    // determines if the #NAMESPACE directive has been used
        bool xdirect = false;   // determines if the code has exited the directive phase (eXited DIRECTives);
        bool includeTrees = false; // determines if an #INCLUDE GSLib.Collections.Trees has been used.

        int lineNumber = 0;

        /// <summary>
        /// Gets a value determining if the required directives have been used
        /// </summary>
        bool Initialized { get { return (ffinit & nsinit); } }

        enum StructState
        {
            StructDeclare,
            StructOpen
        }

        Stack<StructState> structState = new Stack<StructState>();

        #endregion

        public CodeGen(string inputFile, string outputFile, T fileObj)
        {
            // Create language class
            file = fileObj;

            // Add comments
            file.AddComment("Generated by FileFormat " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString());
            file.AddComment("FileFormat is available at http://www.gridersoftware.com");
            file.AddBlankLine();

            // Add dependancies
            file.AddInclude("System");
            file.AddInclude("System.IO");
            file.AddInclude("System.Text");
            file.AddInclude("System.Collections.Generic");
            file.AddBlankLine();

            // Setup constants
            constants = new Dictionary<string, Constant>();

            // Parse file and output result
            try
            {
                ParseFile(inputFile);
            }
            catch (FileNotFoundException)
            {
                Program.PrintError("File \"" + inputFile + "\" not found", 0);
                return;
            }
            catch (Exception ex)
            {
                Program.PrintError("Unhandled exception: " + ex.Message, lineNumber);
                Console.WriteLine(ex.StackTrace);
                return;
            }

            string[] output = file.Build();

            if (CompileFlags.PrintOutput) PrintFile(output);
            File.WriteAllLines(outputFile, output);
        }

        private void PrintFile(string[] lines)
        {
            foreach (string line in lines)
            {
                Console.WriteLine(line);
            }
        }

        private void ParseFile(string file)
        {
            string[] lines;

            if (!File.Exists(file)) throw new FileNotFoundException();
            lines = File.ReadAllLines(file);

            for (int i = 0; i < lines.Length; i++)
            {
                string line = lines[i];
                line = line.Trim();
                string[] parts = line.Split(' ');

                lineNumber = i + 1;

                if (line != "")
                {
                    if (line.StartsWith("#")) ParseDirective(line);
                    else if ((!Regex.IsMatch(line, "(^//.*)|(^/\\*.*\\*/$)"))   // single-line comment
                            && (!Regex.IsMatch(line, "^(/\\*).*"))              // start multi-line comment
                            && (!Regex.IsMatch(line, ".*(\\*/)$")))             // end multi-line comment
                    {
                        // otherwise, check if the #FORMATNAME directive has been used
                        if (!Initialized)
                            Console.WriteLine("Syntax error: expected \"#FORMATNAME\". Line {0}", i + 1);
                        else
                            ParseLine(line);
                    }
                }
            }
        }

        void ParseDirective(string line)
        {
            string[] parts = line.Split(' ');

            if (!xdirect)
            {
                if (Regex.IsMatch(line, "#FORMATNAME [A-Za-z]+[a-z0-9]{0,}"))     // #FORMATNAME directive
                {
                    file.Name = parts[1];

                    // check if this directive has been used. if not, initialize. otherwise, print an error
                    if (!ffinit) ffinit = true;
                    else Program.PrintError("#FORMATNAME directive can only be used once.", lineNumber);
                }
                else if (Regex.IsMatch(line, "#INCLUDE (([_A-Za-z][\\w]+)\\.?)*([_A-Za-z][\\w]+)$"))
                {
                    file.AddInclude(parts[1]);
                    if (parts[1] == "GSLib.Collections.Trees") includeTrees = true;
                }
                else if (Regex.IsMatch(line, "#NAMESPACE @?(([_A-Za-z][\\w]+)\\.?)*([_A-Za-z][\\w]+)$"))  // #NAMESPACE directive
                {
                    ns = (T)file.GetNewMember(StructureType.Namespace, parts[1], AccessModifiers.None, "");
                    file.AddMember(ns);

                    if (!nsinit) nsinit = true;
                    else Program.PrintError("#NAMESPACE directive can only be used once.", lineNumber);
                }
                else if (Regex.IsMatch(line, "#CONST (bool|s?byte|u?int(16|32|64)|float|double|decimal|string|char) @?(([_A-Za-z][\\w]+)\\.?)*([_A-Za-z][\\w]+)$ .*"))
                {
                    string[] substring;
                    string val = "";

                    if (parts[1] == "string" | parts[1] == "char")
                    {
                        string regx;

                        if (parts[1] == "string") regx = "(\")";
                        else regx = "(\')";

                        substring = Regex.Split(line, regx);
                        StringBuilder sb = new StringBuilder();

                        for (int i = 1; i < substring.Length; i++)
                        {
                            sb.Append(substring[i]);
                        }
                        val = sb.ToString();

                        if (!((substring[1] == "\"") && (substring.Last() == "\"")))
                            Program.PrintError("Invalid " + parts[1] + " value.", lineNumber);
                    }
                    else
                    {
                        val = parts[3];
                    }

                    constants.Add(parts[2], new Constant() { typecode = Variable.GetTypeCode(parts[1]), value = val });
                }
                else if (Regex.IsMatch(line, "#MAGICNUMBER (bool|s?byte|u?int(16|32|64)|float|double|decimal|string|char) .*")) // #MAGICNUMBER directive
                {
                    string[] substring;
                    string val = "";

                    if (parts[1] == "string" | parts[1] == "char")
                    {
                        string regx;

                        if (parts[1] == "string") regx = "(\")";
                        else regx = "(\')";

                        substring = Regex.Split(line, regx);
                        StringBuilder sb = new StringBuilder();

                        for (int i = 1; i < substring.Length; i++)
                        {
                            sb.Append(substring[i]);
                        }
                        val = sb.ToString();

                        if (!((substring[1] == "\"") && (substring.Last() == "\"")))
                            Program.PrintError("Invalid " + parts[1] + " value.", lineNumber);
                    }
                    else
                    {
                        val = parts[2];
                    }

                    constants.Add("MAGICNUMBER", new Constant() { typecode = Variable.GetTypeCode(parts[1]), value = val });

                    // assign to magic number
                }
                else if (Regex.IsMatch(line, "#ENCODING (utf7|utf8|utf32|unicode|ascii)")) // #ENCODING directive
                {
                    constants.Add("ENCODING", new Constant() { typecode = TypeCode.String, value = parts[1] });
                }
            }
        }

        void ParseLine(string line)
        {
            xdirect = true;    // set that there are no more directives
            string[] parts = line.Split(' ');

            if (Regex.IsMatch(line, "(bool|s?byte|u?int(16|32|64)|float|double|decimal|string|char) \\$[a-z]*[a-z0-9]{0,} :: (MAGICNUMBER|\\$[a-z]*[a-z0-9]{0,})")) // single variable with compare
            {
                // setup aliases for the parts
                string type = parts[0];
                string name = parts[1];
                string cmpname = parts[3];

                CreateVariable(name, type, cmpname);
            }
            else if (Regex.IsMatch(line, "(bool|s?byte|u?int(16|32|64)|float|double|decimal|string|char) \\$[a-z]*[a-z0-9]{0,}"))   // single variable (no compare)
            {
                CreateVariable(parts[1], parts[0]);
            }
            else if (Regex.IsMatch(line, "(bool|s?byte|u?int(16|32|64)|float|double|decimal|string|char)\\[([0-9]*|(\\$[a-z]*[a-z0-9]{0,}))] \\$[a-z]*[a-z0-9]{0,}")) // array variable
            {
                string[] substrings = Regex.Split(line, "\\[|\\]| ");

                string type = substrings[0];
                string countVar = substrings[1];
                string name = substrings[3];
                int count;

                // if the element count is a variable
                if (countVar.StartsWith("$"))
                    CreateArray(name, type, countVar);
                else
                {
                    if (int.TryParse(substrings[1], out count))
                        CreateArray(name, type, count);
                    else
                        Program.PrintError("Value \"" + countVar + "\" is not a variable or int32 constant.", lineNumber);
                }
            }
            else if (Regex.IsMatch(line, "tree [A-Za-z]*[a-z0-9]{0,} \\$[a-z]*[a-z0-9]{0,}"))
            {
                string structName = parts[1];
                string name = parts[2];

                newest = CreateTree(name, structName);
                structState.Push(StructState.StructDeclare);
            }
            else if (Regex.IsMatch(line, "tree\\[([0-9]*|(\\$[a-z]*[a-z0-9]{0,}))] [A-Za-z]*[a-z0-9]{0,} \\$[a-z]*[a-z0-9]{0,}"))
            {
                if (!includeTrees) Program.PrintWarning("You should #INCLUDE GSLib.Collections.Trees to use the Tree<> class.", lineNumber);

                string[] substrings = Regex.Split(line, "\\[|\\]| ");

                string countVal = substrings[1];
                string structName = substrings[3];
                string name = substrings[4];
                int count;

                if ((structState.Count > 0) && (structState.Peek() == StructState.StructDeclare)) Program.PrintError("\'{\' Expected.", lineNumber);

                // if the element count is a variable
                if (countVal.StartsWith("$"))
                    newest = CreateTree(name, structName, countVal);
                else
                {
                    if (int.TryParse(countVal, out count))
                        newest = CreateTree(name, structName, count);
                    else
                        Program.PrintError("Value \"" + countVal + "\" is not a variable or int32 constant.", lineNumber);
                }

                structState.Push(StructState.StructDeclare);
            }
            else if (Regex.IsMatch(line, "struct\\[([0-9]*|(\\$[a-z]*[a-z0-9]{0,}))] [A-Za-z]*[a-z0-9]{0,} \\$[a-z]*[a-z0-9]{0,}"))  // struct
            {
                string[] substrings = Regex.Split(line, "\\[|\\]| ");

                string countVal = substrings[1];
                string structName = substrings[3];
                string name = substrings[4];
                int count;

                if ((structState.Count > 0) && (structState.Peek() == StructState.StructDeclare)) Program.PrintError("\'{\' Expected.", lineNumber);

                // if the element count is a variable
                if (countVal.StartsWith("$"))
                    newest = CreateStruct(name, structName, countVal);
                else
                {
                    if (int.TryParse(countVal, out count))
                        newest = CreateStruct(name, structName, count);
                    else
                        Program.PrintError("Value \"" + countVal + "\" is not a variable or int32 constant.", lineNumber);
                }

                structState.Push(StructState.StructDeclare);
            }
            else if (line == "{") // struct block opening
            {
                if ((structState.Count > 0) && (structState.Peek() == StructState.StructOpen)) Program.PrintError("\'}\' Expected.", lineNumber);
                else if (structState.Count == 0) Program.PrintError("Unexpected \'{\'.", lineNumber);

                current = newest;
                structState.Push(StructState.StructOpen);
            }
            else if (line == "}") // struct block closing
            {
                if ((structState.Count > 0) && (structState.Peek() == StructState.StructDeclare)) Program.PrintError("\'{\' Expected.", lineNumber);
                else if (structState.Count == 0) Program.PrintError("Unexpected \'}\'.", lineNumber);

                if (current.Parent != null) current = current.Parent;

                if (structState.Count >= 2)
                {
                    structState.Pop();
                    structState.Pop();
                }
            }
            else
            {
                Program.PrintError("Syntax error.", lineNumber);
            }
        }

        void PrintException(Exception ex, int line)
        {
            Program.PrintError("Internal - " + ex.Message, line);
        }

        bool CheckForGlobalName(string name)
        {
            CompoundType<T> head = root;

            if (head.ContainsName(name))
            {
                Program.PrintError("Variable or struct with the name \"" + name + "\" already exists.", lineNumber);
                return true;
            }
            return false;
        }

        bool TryParseLocalName(string name, out Variable v)
        {
            v = null;

            try
            {
                v = current.Variables[name];
                if (v != null) return true;
                else return false;
            }
            catch
            {
                return false;
            }

        }

        bool TryParseTypeCode(string s, out TypeCode type)
        {
            type = Variable.GetTypeCode(s);
            if (type == TypeCode.Empty)
            {
                Program.PrintError("Invalid type \"" + s + "\".", lineNumber);
                return false;
            }
            else if ((type == TypeCode.String) | (type == TypeCode.Char))
            {
                // if the user used a string or char without defining encoding, print a warning
                if (!constants.ContainsKey("ENCODING"))
                    Program.PrintWarning("#ENCODING directive not used. No Encoding set for string and char values.", lineNumber);
            }
            return true;
        }

        void CreateVariable(string name, string type)
        {
            TypeCode t;
            Variable v;

            // Check for problems
            if (CheckForGlobalName(name) | !TryParseTypeCode(type, out t)) return;

            // try to create variable. If this generates an error, there's a major problem somewhere
            try
            {
                v = new Variable(name, t);
                current.Variables.Add(v);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateVariable(" + name + ", " + type + ") - " + ex.Message, lineNumber);
            }
        }

        void CreateVariable(string name, string type, string cmpName)
        {
            TypeCode t;
            Variable v;
            string cmp;

            if (CheckForGlobalName(name) | !TryParseTypeCode(type, out t)) return;

            if (cmpName == "MAGICNUMBER")
                cmp = cmpName;
            else if (CheckForGlobalName(cmpName))
                cmp = cmpName;
            else
                return;

            try
            {
                v = new Variable(name, t);
                v.CompareWith = cmp;
                current.Variables.Add(v);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateVariable(" + name + ", " + type + "," + cmpName + ") - " + ex.Message, lineNumber);
            }
        }

        void CreateArray(string name, string type, int count)
        {
            TypeCode t;
            Variable v;

            // Check for problems. If something isn't right, exit.
            if (CheckForGlobalName(name) | !TryParseTypeCode(type, out t)) return;
            if (count <= 1)
            {
                Program.PrintError("Cannot create an array with less than 2 elements.", lineNumber);
                return;
            }

            // Try to create variable. If this generates an error, there's major problem somewhere.
            try
            {
                v = new Variable(name, count, t);
                current.Variables.Add(v);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateArray(" + name + "," + count.ToString() + "," + type + ") - " + ex.Message, lineNumber);
            }
        }

        void CreateArray(string name, string type, string countVar)
        {
            TypeCode t;
            Variable v, cv;

            // Check for problems. If something isn't right, exit.
            if (CheckForGlobalName(name) | !TryParseTypeCode(type, out t)) return;
            if (!TryParseLocalName(countVar, out cv)) return;
            if (cv.TypeCode != TypeCode.Int32)
            {
                Program.PrintError("Count variable must be an int32.", lineNumber);
                return;
            }

            try
            {
                v = new Variable(name, cv, t);
                current.Variables.Add(v);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateArray(" + name + "," + countVar + "," + type + ") - " + ex.Message, lineNumber);
            }
        }

        CompoundType<T> CreateStruct(string name, string structName, int count)
        {
            CompoundType<T> c = null;

            if (CheckForGlobalName(name)) return null;
            if (count <= 1)
            {
                Program.PrintError("Cannot create an array with less than 2 elements.", lineNumber);
                return null;
            }

            try
            {
                c = new CompoundType<T>(name, structName, count, current);
                current.Structs.Add(c);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateStruct(" + name + "," + structName + "," + count.ToString() + ") - " + ex.Message, lineNumber);
            }

            return c;
        }

        CompoundType<T> CreateStruct(string name, string structName, string countVar)
        {
            Variable cv;
            CompoundType<T> c = null;

            if (CheckForGlobalName(name)) return null;
            if (!TryParseLocalName(countVar, out cv)) return null;

            try
            {
                c = new CompoundType<T>(name, structName, cv, current);
                current.Structs.Add(c);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateStruct(" + name + "," + structName + "," + countVar + ") - " + ex.Message, lineNumber);
            }

            return c;
        }

        CompoundType<T> CreateTree(string name, string typeName)
        {
            CompoundType<T> c = null;

            if (CheckForGlobalName(name)) return null;
            try
            {
                c = CompoundType<T>.CreateTree(name, typeName, 1, current);
                current.Structs.Add(c);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateTree(" + name + "," + typeName + ") - " + ex.Message, lineNumber);
                return null;
            }

            return c;
        }

        CompoundType<T> CreateTree(string name, string typeName, int count)
        {
            CompoundType<T> c = null;

            if (CheckForGlobalName(name)) return null;
            if (count < 1)
            {
                Program.PrintError("Cannot create a tree with less than 1 root node.", lineNumber);
                return null;
            }

            try
            {
                c = CompoundType<T>.CreateTree(name, typeName, count, current);
                current.Structs.Add(c);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateTree(" + name + "," + typeName + "," + count.ToString() + ") - " + ex.Message, lineNumber);
            }

            return c;
        }

        CompoundType<T> CreateTree(string name, string typeName, string countVar)
        {
            Variable cv;
            CompoundType<T> c = null;

            if (CheckForGlobalName(name)) return null;
            if (!TryParseLocalName(countVar, out cv)) return null;

            try
            {
                c = CompoundType<T>.CreateTree(name, typeName, cv, current);
                current.Structs.Add(c);
            }
            catch (Exception ex)
            {
                Program.PrintError("@CodeGen.CreateTree(" + name + "," + typeName + "," + countVar + ") - " + ex.Message, lineNumber);
            }

            return c;
        }
    }
}
